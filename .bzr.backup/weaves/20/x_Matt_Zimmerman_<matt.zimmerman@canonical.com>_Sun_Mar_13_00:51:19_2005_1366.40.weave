# bzr weave file v5
i
1 852abb68407f3c96c698929f15e2aa77e70bf462
n Arch-1:matt.zimmerman@canonical.com%casper--main--0--base-0

i
1 d303b7a516aeca7c6c5f401cb4c4d9f50cfaee0b
n Arch-1:matt.zimmerman@canonical.com--2004%casper--main--0--base-0

i 1
1 852abb68407f3c96c698929f15e2aa77e70bf462
n Arch-1:matt.zimmerman@canonical.com--2004%casper--main--0--patch-3

i 2 0
1 852abb68407f3c96c698929f15e2aa77e70bf462
n mdz@mizar-20051205230117-c327e75be767f237

i 3
1 28b4f20f39bbd46d6c8d9fd9b3bcaf737a9c0ce7
n tfheen@ubuntu.com-20051214125210-b707328a280a0594

i 4
1 3b372fc0533a87ee733ee37f8c75a43bc803d941
n tfheen@ubuntu.com-20060328114038-18560924f7bc62e7

i 5
1 9a306ded60c0aaff41888509552d27933d9f86a9
n tfheen@ubuntu.com-20060419093518-c2a5c65c0a4779df

w
{ 0
. #!/bin/sh
[ 4
. 
. # XXX devfs compatibility junk, see 30copy-dev
. CDROMS=/root/cdroms
. if [ -d $CDROMS ]; then
.     mount -wo remount /dev
.     cp -a $CDROMS /dev
.     mount -ro remount /dev
. fi
] 4
. 
. # Try to cache everything we're likely to need after ejecting.  This
. # is fragile and simple-minded, but our options are limited.
. cache_path() {
.     path="$1"
. 
.     if [ -d "$path" ]; then
.         find "$path" -type f | xargs cat > /dev/null 2>&1
.     elif [ -f "$path" ]; then
.         if [ -x "$path" ]; then
.             if file "$path" | grep -q 'dynamically linked'; then
.                 for lib in $(ldd "$path" | awk '{ print $3 }'); do
.                     cache_path "$lib"
.                 done
.             fi
.         fi
.         cat "$path" >/dev/null 2>&1
.     fi
. }
. 
. for path in $(which halt) $(which reboot) /etc/rc?.d /etc/default; do
.     cache_path "$path"
. done
. 
. eject -p -m /cdrom >/dev/null 2>&1
. 
. # XXX - i18n
. echo -n "Please remove the disc, close the tray (if any) and press ENTER: "
{ 5
. if [ -x /sbin/usplash_write ]; then
[ 6
.     /sbin/usplash_write "TEXT Please remove the disc, close the tray (if any) and press ENTER"
] 6
{ 6
.     /sbin/usplash_write "TIMEOUT 0"
.     /sbin/usplash_write "TEXT Please remove the disc, close the tray (if any)"
.     /sbin/usplash_write "TEXT and press ENTER to continue"
}
. fi
. 
}
. read x
. 
. exit 0
}
{ 1
[ 3
. #!/bin/sh
. 
. # XXX devfs compatibility junk, see 30copy-dev
. CDROMS=/root/cdroms
. if [ -d $CDROMS ]; then
.     mount -wo remount /dev
.     cp -a $CDROMS /dev
.     mount -ro remount /dev
. fi
. 
. # Try to cache everything we're likely to need after ejecting.  This
. # is fragile and simple-minded, but our options are limited.
. cache_path() {
.     path="$1"
. 
.     if [ -d "$path" ]; then
.         find "$path" -type f | xargs cat > /dev/null 2>&1
.     elif [ -f "$path" ]; then
.         if [ -x "$path" ]; then
.             if file "$path" | grep -q 'dynamically linked'; then
.                 for lib in $(ldd "$path" | awk '{ print $3 }'); do
.                     cache_path "$lib"
.                 done
.             fi
.         fi
.         cat "$path" >/dev/null 2>&1
.     fi
. }
. 
. for path in $(which halt) $(which reboot) /etc/rc?.d /etc/default; do
.     cache_path "$path"
. done
. 
[ 2
. eject -p -m /cdrom
] 2
{ 2
. eject -p -m /cdrom >/dev/null 2>&1
}
. 
. # XXX - i18n
[ 2
. echo -n "Please remove the disc and press ENTER: "
] 2
{ 2
. echo -n "Please remove the disc, close the tray (if any) and press ENTER: "
}
. read x
. 
. exit 0
}
] 3
W
