# bzr weave file v5
i
1 e7c976e4db1a5ad5f75cc4b50be538d0eb952309
n Arch-1:matt.zimmerman@canonical.com%casper--main--0--base-0

i
1 e7c976e4db1a5ad5f75cc4b50be538d0eb952309
n Arch-1:matt.zimmerman@canonical.com--2004%casper--main--0--base-0

i 1
1 e7c976e4db1a5ad5f75cc4b50be538d0eb952309
n Arch-1:colin.watson@canonical.com--2005%casper--translations--0--patch-17

i 1 0
1 e7c976e4db1a5ad5f75cc4b50be538d0eb952309
n Arch-1:matt.zimmerman@canonical.com%casper--main--0--patch-5

i 3
1 b743f4a5ac3d443cf889d57229c202c5b9329d67
n Arch-1:colin.watson@canonical.com--2005%casper--fixes--0--patch-2

i 3
1 9539af955ab98e0d08fd36348c671eed433c7df7
n Arch-1:matt.zimmerman@canonical.com%casper--main--0--patch-23

i 5 4
1 9539af955ab98e0d08fd36348c671eed433c7df7
n mdz@mizar-20051205230117-c327e75be767f237

w
{ 0
. #!/bin/sh
. 
. set -e
. 
. . /usr/share/debconf/confmodule
. 
. log() {
.     logger -t casper "$@"
. }
. 
. requested_cow_size() {
.     db_get casper-udeb/snapshot/cow-size
[ 5
.     COW_SIZE_TEXT="$RET"
.     case "$COW_SIZE_TEXT" in
] 5
{ 5
.     cow_size_text="$RET"
.     case "$cow_size_text" in
}
.         *[Mm])
.             # Megabytes->sectors
[ 5
.             RET=$((${COW_SIZE_TEXT%%[Mm]} * 2048))
] 5
{ 5
.             RET=$((${cow_size_text%%[Mm]} * 2048))
}
.             ;;
. 
.         *[Gg])
.             # Gigabytes->sectors
[ 5
.             RET=$((${COW_SIZE_TEXT%%[Gg]} * 2097152))
] 5
{ 5
.             RET=$((${cow_size_text%%[Gg]} * 2097152))
}
.             ;;
.         auto)
.             # XXX, should limit based on available RAM
.             RET=""
.             ;;
.         *)
[ 5
.             RET=$COW_SIZE_TEXT
] 5
{ 5
.             RET=$cow_size_text
}
.     esac
. 
.     echo -n $RET
. }
. 
. backing_file() {
.     db_get casper-udeb/snapshot/backing-file
.     echo -n $RET
. }
. 
. cow_device() {
.     db_get casper-udeb/snapshot/cow-device
.     echo -n $RET
. }
. 
[ 4
[ 5
. db_input casper-udeb/snapshot/backing-file || true
. db_input casper-udeb/snapshot/cow-device || true
. db_input casper-udeb/snapshot/cow-size || true
] 4
{ 4
. db_input low casper-udeb/snapshot/backing-file || true
. db_input low casper-udeb/snapshot/cow-device || true
. db_input low casper-udeb/snapshot/cow-size || true
}
] 5
{ 5
. cow_mode() {
.     db_get casper-udeb/snapshot/cow-mode
.     echo -n $RET
. }
. 
. db_input low casper-udeb/snapshot/cow-mode || true
. db_input low casper-udeb/snapshot/backing-file || true
. db_input low casper-udeb/snapshot/cow-device || true
. db_input low casper-udeb/snapshot/cow-size || true
}
. db_go
. 
[ 5
. BACKING_FILE=$(backing_file)
. COW_DEVICE=$(cow_device)
. COW_SIZE=$(requested_cow_size)
] 5
{ 5
. mkdir /target
}
. 
[ 5
. COW_NAME="casper-cow"
. SNAPSHOT_NAME="casper-snapshot"
. SNAPSHOT_DEV="/dev/mapper/$SNAPSHOT_NAME"
. COW_DM_DEVICE="/dev/mapper/$COW_NAME"
. LOOP_DEVICE="/dev/cloop0"
] 5
{ 5
. setup_cloop() {
.     backing_file="$1"
.     loop_device="/dev/cloop0"
}
. 
[ 5
. if [ -b $SNAPSHOT_DEV ]; then
.     log "Snapshot device $SNAPSHOT_DEV already exists"
. else
.     log "Configuring snapshot..."
] 5
{ 5
.     log "Setting up loop device $loop_device"
.     losetup $loop_device $backing_file
}
. 
[ 5
.     losetup $LOOP_DEVICE $BACKING_FILE
] 5
{ 5
.     echo -n $loop_device
. }
}
. 
[ 5
.     BACKING_FILE_SIZE=$(blockdev --getsize "$LOOP_DEVICE")
.     MAX_COW_SIZE=$(blockdev --getsize "$COW_DEVICE")
.     CHUNK_SIZE=8 # sectors
] 5
{ 5
. setup_loop() {
.     backing_file="$1"
.     loop_device="/dev/loop0"
}
. 
[ 5
.     if [ -z "$COW_SIZE" -o "$COW_SIZE" -gt "$MAX_COW_SIZE" ]; then
.         COW_SIZE=$MAX_COW_SIZE
] 5
{ 5
.     log "Setting up loop device $loop_device"
.     losetup $loop_device $backing_file
. 
.     echo -n $loop_device
. }
. 
. mount_dm_cow() {
.     backing_device="$1"
.     cow_device="$2"
.     cow_size="$3"
. 
.     cow_name="casper-cow"
.     snapshot_name="casper-snapshot"
.     snapshot_dev="/dev/mapper/$snapshot_name"
.     cow_dm_device="/dev/mapper/$cow_name"
. 
.     if [ -b $snapshot_dev ]; then
.         log "Device-mapper snapshot device $snapshot_dev already exists"
.     else
.         log "Configuring device-mapper snapshot..."
. 
.         backing_file_size=$(blockdev --getsize "$backing_device")
.         max_cow_size=$(blockdev --getsize "$cow_device")
.         chunk_size=8 # sectors
. 
.         if [ -z "$cow_size" -o "$cow_size" -gt "$max_cow_size" ]; then
.             cow_size=$max_cow_size
.         fi
. 
.         echo "0 $cow_size linear $cow_device 0" | \
.             dmsetup create $cow_name
. 
.         echo "0 $backing_file_size snapshot $backing_device $cow_dm_device p $chunk_size" | \
.             dmsetup create $snapshot_name
}
.     fi
. 
[ 5
.     echo "0 $COW_SIZE linear $COW_DEVICE 0" | \
.         dmsetup create $COW_NAME
] 5
{ 5
.     log "Mounting device-mapper snapshot..."
.     mount -o noatime $snapshot_dev /target
. }
}
. 
[ 5
.     echo "0 $BACKING_FILE_SIZE snapshot $LOOP_DEVICE $COW_DM_DEVICE p $CHUNK_SIZE" | \
.         dmsetup create $SNAPSHOT_NAME
] 5
{ 5
. mount_unionfs_cow() {
.     backing_device="$1"
.     cow_device="$2" # XXX ignored
.     cow_size="$3" # XXX ignored
. 
.     anna-install unionfs-modules-$(uname -r)-di
. ## FIXME: should not modules call depmod -a in their postinst?
.     if [ -x /sbin/depmod ]; then
.         depmod -a > /dev/null 2>&1 || true
.     fi
.     modprobe -v unionfs >> /var/log/messages 2>&1
.     mkdir /cow
.     mount -t tmpfs tmpfs /cow
.     mkdir /rofs
.     mount $backing_device /rofs
.     mount -t unionfs -o dirs=/cow=rw:/rofs=ro unionfs /target
. }
. 
. 
. if [ "$(cow_mode)" = "UnionFS" ]; then
.     log "Mounting with unionfs"
.     mount_unionfs_cow $(setup_cloop $(backing_file)) $(cow_device) $(requested_cow_size)
. else
.     mount_dm_cow $(setup_cloop $(backing_file)) $(cow_device) $(requested_cow_size)
}
. fi
. 
[ 5
. log "Mounting snapshot..."
. mkdir /target
. mount -o noatime $SNAPSHOT_DEV /target
. 
] 5
. exit 0
}
{ 1
[ 3
. #!/bin/sh
. 
. set -e
. 
. . /usr/share/debconf/confmodule
. 
. log() {
.     logger -t casper "$@"
. }
. 
. requested_cow_size() {
.     db_get casper-udeb/snapshot/cow-size
.     COW_SIZE_TEXT="$RET"
.     case "$COW_SIZE_TEXT" in
.         *[Mm])
.             # Megabytes->sectors
.             RET=$((${COW_SIZE_TEXT%%[Mm]} * 2048))
.             ;;
. 
.         *[Gg])
.             # Gigabytes->sectors
.             RET=$((${COW_SIZE_TEXT%%[Gg]} * 2097152))
.             ;;
.         auto)
.             # XXX, should limit based on available RAM
.             RET=""
.             ;;
.         *)
.             RET=$COW_SIZE_TEXT
.     esac
. 
.     echo -n $RET
. }
. 
. backing_file() {
.     db_get casper-udeb/snapshot/backing-file
.     echo -n $RET
. }
. 
. cow_device() {
.     db_get casper-udeb/snapshot/cow-device
.     echo -n $RET
. }
. 
. db_input casper-udeb/snapshot/backing-file || true
. db_input casper-udeb/snapshot/cow-device || true
. db_input casper-udeb/snapshot/cow-size || true
. db_go
. 
. BACKING_FILE=$(backing_file)
. COW_DEVICE=$(cow_device)
. COW_SIZE=$(requested_cow_size)
. 
. COW_NAME="casper-cow"
. SNAPSHOT_NAME="casper-snapshot"
. SNAPSHOT_DEV="/dev/mapper/$SNAPSHOT_NAME"
. COW_DM_DEVICE="/dev/mapper/$COW_NAME"
. LOOP_DEVICE="/dev/cloop0"
. 
. if [ -b $SNAPSHOT_DEV ]; then
.     log "Snapshot device $SNAPSHOT_DEV already exists"
. else
.     log "Configuring snapshot..."
. 
.     losetup $LOOP_DEVICE $BACKING_FILE
. 
.     BACKING_FILE_SIZE=$(blockdev --getsize "$LOOP_DEVICE")
.     MAX_COW_SIZE=$(blockdev --getsize "$COW_DEVICE")
.     CHUNK_SIZE=8 # sectors
. 
.     if [ -z "$COW_SIZE" -o "$COW_SIZE" -gt "$MAX_COW_SIZE" ]; then
.         COW_SIZE=$MAX_COW_SIZE
.     fi
. 
.     echo "0 $COW_SIZE linear $COW_DEVICE 0" | \
.         dmsetup create $COW_NAME
. 
.     echo "0 $BACKING_FILE_SIZE snapshot $LOOP_DEVICE $COW_DM_DEVICE p $CHUNK_SIZE" | \
.         dmsetup create $SNAPSHOT_NAME
. fi
. 
. log "Mounting snapshot..."
. mkdir /target
. mount -o noatime $SNAPSHOT_DEV /target
. 
. exit 0
}
] 3
W
