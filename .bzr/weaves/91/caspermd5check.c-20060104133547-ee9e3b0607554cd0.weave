# bzr weave file v5
i
1 082da03470d62a7baf2b298b2abed8e7b8b83db2
n tfheen@ubuntu.com-20060104133831-6464ce2d1d0a5197

i 0
1 6e5b18168470b98e89d3e2a516844d51788dba19
n tfheen@ubuntu.com-20060104143346-938e8027e7d772d1

i 1
1 72a1e40f092d27219100344edb9ebe3365b5f7e8
n tfheen@ubuntu.com-20060104144402-9dd46cd60a62996d

i 2
1 863ce24e2ea26f760da2d8361431c49c69df451b
n tfheen@ubuntu.com-20060104145012-d4ade72746ad3e75

i 3
1 0b777360955129173ee94905b0f93c6f1a8d2b12
n tfheen@ubuntu.com-20060104145916-be87bb0a3a7836b5

i 4
1 5fc657e141a474784d883ca120b477f68ab740fd
n tfheen@ubuntu.com-20060104150000-c22feb07ce4c4bc8

i 5
1 c6f7dd5cc4aedc4135f02ec1f32aaf9cb3800e69
n tfheen@ubuntu.com-20060104151027-2bebd97a0201056c

i 6
1 12a2b46969821d570fe25f2c999b0467c49b0a6f
n tfheen@ubuntu.com-20060104151217-5f6cc3ebb6f15a98

i 7
1 dad61194755b5c251254d9d89d210aeeaf81ff98
n tfheen@ubuntu.com-20060104180501-57bdd5864aa0deda

i 8
1 641b7b842f7010fbdcd0c2c11d3d4be02f68f16b
n tfheen@ubuntu.com-20060104181118-5198da49b20a73df

i 9
1 c4df2eb941906af894e29f3f261d25ef741370cf
n tfheen@ubuntu.com-20060104181743-1c28a2141559b449

i 10
1 7dff24449f4afb4580ed0ef199b47b131575be0b
n tfheen@ubuntu.com-20060105032824-7c201333ba14e586

i 11
1 b79b7f90156377af8bfb006f884178e9d06e58ed
n tfheen@ubuntu.com-20060105033036-ae991fa67eaafd65

i 12
1 56951d38629f8d320af22bb3dcc85d3e76c775a1
n tfheen@ubuntu.com-20060105033706-3bb62e30b3ffd259

i 13
1 4362b0d96f2ef6df66897d3ba9d7ba8db3e69d0f
n tfheen@ubuntu.com-20060109105158-c46896c744448553

i 14
1 5ca2cc66591a599554f620c7fcd6b4b09ec0c9ec
n tfheen@ubuntu.com-20060214135237-70a840f6debc50d8

w
{ 0
. /* casper-md5check - a tool to check md5sums and talk to usplash
.    (C) Canonical Ltd 2006
.    Written by Tollef Fog Heen <tfheen@ubuntu.com>
. 
.    This program is free software; you can redistribute it and/or
.    modify it under the terms of the GNU General Public License as
.    published by the Free Software Foundation; either version 2 of the
.    License, or (at your option) any later version.
.    
.    This program is distributed in the hope that it will be useful, but
.    WITHOUT ANY WARRANTY; without even the implied warranty of
.    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
.    General Public License for more details.
.    
.    You should have received a copy of the GNU General Public License
.    along with this program; if not, write to the Free Software
.    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
.    USA. */
. 
. #include <stdio.h>
. #include <unistd.h>
. #include <string.h>
. #include <errno.h>
. #include <stdarg.h>
. #include <sys/types.h>
. #include <sys/stat.h>
. #include <fcntl.h>
. #include <stdlib.h>
[ 6
. 
] 6
{ 7
. #include <math.h>
}
. 
[ 14
. #define USPLASH_FIFO "/dev/usplash_fifo"
{ 8
] 14
{ 14
. #define USPLASH_FIFO "/dev/.initramfs/usplash_fifo"
}
. #define MAXTRIES 5
}
. #include "md5.h"
{ 9
. #define DEBUG
}
. 
[ 1
. int usplash_timeout(FILE *f, int timeout) {
.   fprintf(f, "TIMEOUT %d", timeout);
.   fprintf(f, "\0");
.   fflush(f);
] 1
{ 1
[ 12
. int usplash_timeout(int fd, int timeout) {
.   char *s;
{ 8
.   int try;
}
. 
.   asprintf(&s, "TIMEOUT %d", timeout);
[ 8
.   write(fd, s, strlen(s)+1);
] 8
{ 8
{ 9
] 12
{ 12
. int write_and_retry(int fd, char *s) {
.   int try = 0, ret = 0;
.   char *end;
}
. 
. #ifdef DEBUG
.   fprintf(stderr, "-> %s\n", s);
. #endif
}
. 
[ 12
.   errno = EWOULDBLOCK;
.   for (try = 0; try < MAXTRIES && errno == EWOULDBLOCK; try++) {
.     if (write(fd, s, strlen(s)+1) >= 0)
.       break;
] 12
{ 12
.   end = s + strlen(s)+1;
. 
.   ret = write(fd, s, end - s);
.   while (s + ret < end && try < MAXTRIES) {
}
.     sleep(1);
[ 12
.   }
}
] 12
{ 12
.     s += ret;
.     ret = write(fd, s, strlen(s)+1);
.     try++;
.   }
. }
. 
. int usplash_timeout(int fd, int timeout) {
.   char *s;
.   int try;
. 
.   asprintf(&s, "TIMEOUT %d", timeout);
. 
.   write_and_retry(fd, s);
. 
}
.   free(s);
. 
}
. }
. 
[ 1
. void usplash_failure(FILE *f, char *format, ...) {
] 1
{ 1
. void usplash_failure(int fd, char *format, ...) {
[ 2
.   char *s;
}
] 2
{ 2
.   char *s, *s1;
}
{ 8
.   int try;
}
.   va_list argp;
{ 1
{ 8
. 
}
.   va_start(argp, format);
.   vasprintf(&s, format, argp);
.   va_end(argp);
}
. 
[ 1
.   va_start(argp, format);
. 
.   fprintf(f, "FAILURE ");
.   fprintf(f, format, argp);
.   fprintf(f, "\0");
.   fflush(f);
.   va_end(argp);
] 1
{ 1
[ 2
.   write(fd, "FAILURE ", 8);
.   write(fd, s, strlen(s)+1);
.   
] 2
{ 2
[ 3
.   asprintf(&s1, "FAILURE %s" s);
] 3
{ 3
.   asprintf(&s1, "FAILURE %s", s);
}
[ 8
.   write(fd, s1, strlen(s1)+1);
] 8
{ 8
. 
{ 9
[ 12
. #ifdef DEBUG
.   fprintf(stderr, "-> %s\n", s1);
. #endif
. 
}
.   errno = EWOULDBLOCK;
.   for (try = 0; try < MAXTRIES && errno == EWOULDBLOCK; try++) {
.     if (write(fd, s1, strlen(s1)+1) >= 0)
.       break;
.     sleep(1);
.   }
}
] 12
{ 12
.   write_and_retry(fd, s1);
}
. 
}
.   free(s);
}
{ 2
.   free(s1);
}
. }
. 
[ 1
. void usplash_text(FILE *f, char *format, ...) {
] 1
{ 1
. void usplash_text(int fd, char *format, ...) {
[ 2
.   char *s;
}
] 2
{ 2
.   char *s, *s1;
}
{ 8
.   int try;
}
.   va_list argp;
{ 1
{ 8
. 
}
.   va_start(argp, format);
.   vasprintf(&s, format, argp);
.   va_end(argp);
}
. 
[ 1
.   va_start(argp, format);
. 
.   fprintf(f, "TEXT ");
.   fprintf(f, format, argp);
.   fprintf(f, "\0");
.   fflush(f);
.   va_end(argp);
] 1
{ 1
[ 2
.   write(fd, "TEXT ", 5);
.   write(fd, s, strlen(s)+1);
.   
] 2
{ 2
[ 3
.   asprintf(&s1, "TEXT %s" s);
] 3
{ 3
.   asprintf(&s1, "TEXT %s", s);
}
[ 8
.   write(fd, s1, strlen(s1)+1);
] 8
{ 8
. 
{ 9
[ 12
. #ifdef DEBUG
.   fprintf(stderr, "-> %s\n", s1);
. #endif
. 
}
.   errno = EWOULDBLOCK;
.   for (try = 0; try < MAXTRIES && errno == EWOULDBLOCK; try++) {
.     if (write(fd, s1, strlen(s1)+1) >= 0)
.       break;
.     sleep(1);
.   }
}
] 12
{ 12
.   write_and_retry(fd, s1);
}
. 
}
.   free(s);
}
{ 2
.   free(s1);
}
. }
. 
[ 1
. void usplash_success(FILE *f, char *format, ...) {
] 1
{ 1
. void usplash_success(int fd, char *format, ...) {
[ 2
.   char *s;
}
] 2
{ 2
.   char *s, *s1;
}
{ 8
.   int try;
}
.   va_list argp;
{ 1
{ 8
. 
}
.   va_start(argp, format);
.   vasprintf(&s, format, argp);
.   va_end(argp);
}
. 
[ 1
.   va_start(argp, format);
. 
.   fprintf(f, "SUCCESS ");
.   fprintf(f, format, argp);
.   fprintf(f, "\0");
.   fflush(f);
.   va_end(argp);
] 1
{ 1
[ 2
.   write(fd, "SUCCESS ", 8);
.   write(fd, s, strlen(s)+1);
] 2
{ 2
[ 3
.   asprintf(&s1, "SUCCESS %s" s);
] 3
{ 3
.   asprintf(&s1, "SUCCESS %s", s);
}
[ 8
.   write(fd, s1, strlen(s1)+1);
}
] 8
{ 8
. 
{ 9
[ 12
. #ifdef DEBUG
.   fprintf(stderr, "-> %s\n", s1);
. #endif
. 
}
.   errno = EWOULDBLOCK;
.   for (try = 0; try < MAXTRIES && errno == EWOULDBLOCK; try++) {
.     if (write(fd, s1, strlen(s1)+1) >= 0)
.       break;
.     sleep(1);
.   }
}
] 12
{ 12
.   write_and_retry(fd, s1);
}
.   
.   free(s);
}
{ 2
.   free(s1);
}
. }
[ 1
. 
] 1
. 
{ 6
. void usplash_progress(int fd, int progress) {
{ 10
[ 12
.   static int prevprogress = 0;
}
] 12
{ 12
.   static int prevprogress = -1;
}
.   char *s;
{ 8
.   int try;
}
{ 10
. 
.   if (progress == prevprogress)
.     return;
.   prevprogress = progress;
}
. 
[ 7
.   asprintf(&s, "PROGRESS %d", timeout);
] 7
{ 7
.   asprintf(&s, "PROGRESS %d", progress);
}
[ 8
.   write(fd, s, strlen(s)+1);
] 8
{ 8
{ 9
. 
[ 12
. #ifdef DEBUG
.   fprintf(stderr, "-> %s\n", s);
. #endif
}
. 
.   errno = EWOULDBLOCK;
.   for (try = 0; try < MAXTRIES && errno == EWOULDBLOCK; try++) {
.     if (write(fd, s, strlen(s)+1) >= 0)
.       break;
.     sleep(1);
.   }
}
] 12
{ 12
.   write_and_retry(fd, s);
. 
}
.   free(s);
. }
. 
}
. int main(int argc, char **argv) {
[ 4
. 	int pipe_fd, check_fd;
[ 1
.         FILE *pipe_file;
] 1
. 
.         FILE *md5_file;
. 	md5_state_t state;
. 	md5_byte_t digest[16];
. 	char hex_output[16*2 + 1];
.         char *checksum, *checkfile;
. 
. 	if (argc != 3) {
. 		fprintf(stderr,"Wrong number of arguments\n");
. 		exit(1);
. 	}
. 
.         if (chdir(argv[1]) != 0) {
.           perror("chdir");
.           exit(1);
.         }
. 
. 	pipe_fd = open(USPLASH_FIFO, O_WRONLY|O_NONBLOCK);
. 
. 	if (pipe_fd == -1) {
. 		/* We can't really do anything useful here */
. 		exit(1);
. 	}
. 
[ 1
.         pipe_file = fdopen(pipe_fd, "w");
.         if (!pipe_file) {
.           return 1;
.         }
. 
] 1
.         md5_file = fopen(argv[2], "r");
.         if (!md5_file) {
] 4
{ 4
.   
.   int pipe_fd, check_fd;
{ 13
.   int failed = 0;
}
.   
.   FILE *md5_file;
.   md5_state_t state;
.   md5_byte_t digest[16];
.   char hex_output[16*2 + 1];
.   char *checksum, *checkfile;
[ 6
.   
] 6
{ 6
.   ssize_t tsize, csize;
. 
.   tsize = 0;
.   csize = 0;
. 
}
.   if (argc != 3) {
.     fprintf(stderr,"Wrong number of arguments\n");
{ 5
.     fprintf(stderr,"%s <root directory> <md5sum file>\n");
}
.     exit(1);
.   }
.   
.   if (chdir(argv[1]) != 0) {
.     perror("chdir");
.     exit(1);
.   }
.   
.   pipe_fd = open(USPLASH_FIFO, O_WRONLY|O_NONBLOCK);
.   
.   if (pipe_fd == -1) {
.     /* We can't really do anything useful here */
.     exit(1);
.   }
.   
{ 11
.   usplash_progress(pipe_fd, 0);
}
.   md5_file = fopen(argv[2], "r");
.   if (!md5_file) {
}
.           perror("fopen md5_file");
.           exit(1);
[ 4
.         }
[ 1
.         
.         while (fscanf(md5_file, "%as %as", checksum, checkfile) == 2) {
] 1
{ 1
.         while (fscanf(md5_file, "%as %as", &checksum, &checkfile) == 2) {
}
.           char buf[BUFSIZ];
.           ssize_t rsize;
.           int i;
. 
.           md5_init(&state);
. 
[ 1
.           usplash_text(pipe_file, "Checking %s", checkfile);
] 1
{ 1
.           usplash_text(pipe_fd, "Checking %s", checkfile);
}
. 
.           check_fd = open(checkfile, O_RDONLY);
.           if (check_fd < 0) {
[ 1
.             usplash_timeout(pipe_file, 300);
.             usplash_failure(pipe_file, "%s", strerror(errno));
] 1
{ 1
.             usplash_timeout(pipe_fd, 300);
.             usplash_failure(pipe_fd, "%s", strerror(errno));
}
.             sleep(10);
.           }
. 
.           rsize = read(check_fd, buf, sizeof(buf));
. 
.           while (rsize > 0) {
.             md5_append(&state, (const md5_byte_t *)buf, rsize);
.             rsize = read(check_fd, buf, sizeof(buf));
.           }
. 
.           close(check_fd);
.           md5_finish(&state, digest);
. 
.           for (i = 0; i < 16; i++)
. 	    sprintf(hex_output + i * 2, "%02x", digest[i]);
. 
.           if (strncmp(hex_output, checksum, strlen(hex_output)) == 0) {
[ 1
.             usplash_success(pipe_file, "OK");
] 1
{ 1
.             usplash_success(pipe_fd, "OK");
}
.           } else {
[ 1
.             usplash_failure(pipe_file, "md5sum mismatch");
] 1
{ 1
.             usplash_failure(pipe_fd, "md5sum mismatch");
}
.             sleep(10);
.           }
.           free(checksum);
.           free(checkfile);
.         }
[ 1
. 
] 1
{ 1
.         usplash_text(pipe_fd, "Check finished!");
}
.         
. 	return 0;
. 
] 4
{ 4
.   }
.   while (fscanf(md5_file, "%as %as", &checksum, &checkfile) == 2) {
{ 6
.     struct stat statbuf;
. 
.     if (stat(checkfile, &statbuf) == 0) {
.       tsize += statbuf.st_size;
.     }
. 
.     free(checksum);
.     free(checkfile);
.   }
. 
.   rewind(md5_file);
.   while (fscanf(md5_file, "%as %as", &checksum, &checkfile) == 2) {
}
.     char buf[BUFSIZ];
.     ssize_t rsize;
.     int i;
.     
.     md5_init(&state);
.     
.     usplash_text(pipe_fd, "Checking %s", checkfile);
.     
.     check_fd = open(checkfile, O_RDONLY);
.     if (check_fd < 0) {
.       usplash_timeout(pipe_fd, 300);
.       usplash_failure(pipe_fd, "%s", strerror(errno));
.       sleep(10);
.     }
.     
.     rsize = read(check_fd, buf, sizeof(buf));
[ 6
.     
] 6
{ 6
. 
}
.     while (rsize > 0) {
{ 6
.       csize += rsize;
.       usplash_progress(pipe_fd, floor(100*csize/tsize));
. 
}
.       md5_append(&state, (const md5_byte_t *)buf, rsize);
.       rsize = read(check_fd, buf, sizeof(buf));
.     }
.     
.     close(check_fd);
.     md5_finish(&state, digest);
.     
.     for (i = 0; i < 16; i++)
.       sprintf(hex_output + i * 2, "%02x", digest[i]);
.     
.     if (strncmp(hex_output, checksum, strlen(hex_output)) == 0) {
.       usplash_success(pipe_fd, "OK");
.     } else {
[ 13
.       usplash_failure(pipe_fd, "md5sum mismatch");
.       sleep(10);
] 13
{ 13
.       usplash_failure(pipe_fd, "mismatch");
.       failed++;
}
.     }
.     free(checksum);
.     free(checkfile);
.   }
[ 13
.   usplash_text(pipe_fd, "Check finished!");
] 13
{ 13
.   usplash_text(pipe_fd, "Check finished, %d checksums failed", failed);
{ 15
.   usplash_text(pipe_fd, "Please reboot your system", failed);
}
.   usplash_timeout(pipe_fd, 0);
. 
.   while (1) {
.     sleep(3600);
.   }
}
.   
.   return 0;
.   
}
. }
}
W
